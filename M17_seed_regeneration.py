"""
M17_seed_regeneration.py - CLF Regeneration: Ξ(Σ) → S

═══════════════════════════════════════════════════════════════════════
MATHEMATICAL CONTRACT: Regeneration Function Ξ
═══════════════════════════════════════════════════════════════════════

Core Equation:
    ∀ Σ: Ξ(Σ) = S  where θ(S) = Σ

Bijectivity Requirement:
    Ξ(θ(S)) = S    (Recognition → Regeneration = Identity)
    θ(Ξ(Σ)) = Σ    (Regeneration → Recognition = Identity)

Properties (Mathematical Requirements):
    • TOTALITY:      Ξ(Σ) defined for all valid Σ
    • DETERMINISM:   Same Σ → same S (no randomness)
    • EXACTNESS:     Byte-perfect reconstruction (not approximation)
    • CLOSURE:       Uses only information in Σ (no external data)
    • PURITY:        No side effects, no state, no context

⸻

DELETION GUARANTEE:
    If Ξ(θ(S)) = S, then S can be deleted.
    Σ is the causal replacement — complete and sufficient.

This is NOT compression (approximation + entropy loss).
This IS closed logic (total function + completeness).

⸻

CLF ALIGNMENT (See CLF_ALIGNMENT_SPECIFICATION.md):
    This module implements regeneration under strict mathematical closure.
    If Ξ(Σ) ≠ S (original), CLF is violated — not "lossy".
"""

from typing import Dict, Any


def regenerate_from_seed(Sigma: Dict[str, Any]) -> bytes:
    """
    Universal regeneration function: Ξ(Σ) → S (PARSING OPERATION)
    
    CRITICAL SEMANTICS:
    • Input Σ is PRE-PARSING STORAGE: The causal law (stored form)
    • This function PARSES the law: Executes generative logic
    • Output S is POST-PARSING MANIFESTATION: Generated bytes
    
    This is NOT decompression (decoding compressed data)
    This IS parsing (executing generative law → manifestation)
    
    Total function: No exceptions, always returns exactly one S.
    Deterministic: Same Σ always produces same S.
    Byte-perfect: S_regenerated == S_original (exact match).
    
    Args:
        Sigma: The causal seed {family, params, n} (PRE-PARSING law)
        
    Returns:
        S: The exact original string (POST-PARSING manifestation)
        
    Raises:
        ValueError: If seed is invalid or insufficient (violates A1)
    """
    if not Sigma or 'family' not in Sigma:
        raise ValueError("Invalid seed: missing 'family' field")
    
    family = Sigma['family']
    n = Sigma.get('n', 0)
    params = Sigma.get('params', {})
    
    # Route to appropriate law-specific regenerator
    if family == 'D1' or family == 'D1_constant' or family == 'D1_DEDUCED':
        return regenerate_D1_constant(n, params)
    elif family == 'D2' or family == 'D2_affine' or family == 'D2_DEDUCED':
        return regenerate_D2_affine(n, params)
    elif family == 'D3' or family == 'D3_periodic' or family == 'D3_DEDUCED':
        return regenerate_D3_periodic(n, params)
    elif family == 'D4_XOR_AFFINE':
        return regenerate_D4_xor_affine(n, params)
    elif family == 'D5_QUADRATIC':
        return regenerate_D5_quadratic(n, params)
    elif family == 'D6_MIRROR':
        return regenerate_D6_mirror(n, params)
    elif family == 'D7_ROTATIONAL':
        return regenerate_D7_rotational(n, params)
    elif family == 'D9_RADIAL':
        return regenerate_D9_radial(n, params)
    elif family == 'D10_SPIRAL':
        return regenerate_D10_spiral(n, params)
    elif family == 'D0_IDENTITY':
        # Identity law: S[i] = bytes[i]
        return bytes(params['bytes'])
    elif family == 'D_SPLIT':
        return regenerate_D_SPLIT(n, params)
    elif family == 'D11_UNIVERSAL':
        return regenerate_D11_universal(n, params)
    elif family == 'Σ₀':
        return regenerate_Sigma0(n, params)
    elif family == 'D_SPLIT_DEDUCED':
        return regenerate_D_SPLIT_deduced(n, params)
    elif family == 'RAW_BYTES':
        # New family for raw segments (binary or base64 format)
        if 'data' in params:
            # Binary format: direct bytes
            data = params['data']
            if isinstance(data, (bytes, bytearray)):
                return bytes(data)
            elif isinstance(data, list):
                return bytes(data)
            else:
                raise ValueError(f"RAW_BYTES 'data' must be bytes or list, got {type(data)}")
        elif 'data_b64' in params:
            # JSON format: base64-encoded
            import base64
            return base64.b64decode(params['data_b64'])
        else:
            raise ValueError("RAW_BYTES family requires 'data' or 'data_b64' parameter")
    elif family == 'RECURSIVE_DEDUCED' or family == 'ABSTRACT_DEDUCED':
        # These are deduced but incomplete - should have been converted to proper laws
        # Fall back to storing raw data
        if 'data_b64' in params:
            import base64
            return base64.b64decode(params['data_b64'])
        if 'data' in params:
            return bytes(params['data'])
        raise ValueError(
            f"{family} cannot regenerate without complete law or data field. "
            "Deduction should have returned a complete seed."
        )
    else:
        raise ValueError(f"Unknown law family: {family}")


# ========================================
# LAW-SPECIFIC REGENERATORS
# ========================================

def regenerate_D1_constant(n: int, params: Dict[str, Any]) -> bytes:
    """
    D1 Constant Law: S = [c, c, c, ..., c]
    
    Generative formula: S[i] = c for all i
    """
    # Handle multiple parameter names:
    # - 'constant' (strict recognizer)
    # - 'c' (deduction)
    # - 'byte' (reactive recognizer)
    # - 'value' (sampled recognizer)
    if 'constant' in params:
        c = params['constant']
    elif 'c' in params:
        c = params['c']
    elif 'byte' in params:
        c = params['byte']
    elif 'value' in params:
        c = params['value']
    else:
        raise ValueError("D1 seed missing 'constant', 'c', 'byte', or 'value' parameter")
    
    return bytes([c] * n)


def regenerate_D2_affine(n: int, params: Dict[str, Any]) -> bytes:
    """
    D2 Affine Law: S[i] = (s0 + i * delta) mod 256
    
    Generative formula: Arithmetic sequence with wraparound
    """
    # Handle multiple naming conventions:
    # - D2_affine_law uses: 's0' and 'delta_mod'
    # - Deduction uses: 's0' and 'delta'
    # - Alternative: 'start' and 'delta'
    
    if 's0' in params:
        s0 = params['s0']
    elif 'start' in params:
        s0 = params['start']
    else:
        raise ValueError("D2 seed missing 's0' or 'start' parameter")
    
    if 'delta_mod' in params:
        delta = params['delta_mod']
    elif 'delta' in params:
        delta = params['delta']
    else:
        raise ValueError("D2 seed missing 'delta_mod' or 'delta' parameter")
    
    return bytes([(s0 + i * delta) % 256 for i in range(n)])


def regenerate_D3_periodic(n: int, params: Dict[str, Any]) -> bytes:
    """
    D3 Periodic Law: S repeats a pattern
    
    Generative formula: S[i] = pattern[i mod period]
    """
    # Accept both 'pattern' and 'cycle'
    if 'pattern' in params:
        pattern = params['pattern']
    elif 'cycle' in params:
        pattern = params['cycle']
    else:
        raise ValueError("D3 seed missing 'pattern' or 'cycle' parameter")
    
    # Handle both bytes and list representations
    if isinstance(pattern, list):
        pattern = bytes(pattern)
    elif isinstance(pattern, str):
        pattern = pattern.encode('latin1')
    
    period = len(pattern)
    if period == 0:
        raise ValueError("D3 pattern cannot be empty")
    
    # Generate by repeating pattern
    full_repeats = n // period
    remainder = n % period
    
    return pattern * full_repeats + pattern[:remainder]


def regenerate_D4_xor_affine(n: int, params: Dict[str, Any]) -> bytes:
    """
    D4 XOR_AFFINE Law: S[i] = ((s0 + i*delta) mod 256) ⊕ xor_const
    
    Generative formula: Affine sequence XORed with constant
    """
    if 'xor_const' not in params:
        raise ValueError("D4 seed missing 'xor_const' parameter")
    
    xor_const = params['xor_const']
    
    # Get base affine params (handle naming variations)
    if 'base_s0' in params:
        s0 = params['base_s0']
    elif 's0' in params:
        s0 = params['s0']
    else:
        raise ValueError("D4 seed missing 'base_s0' or 's0' parameter")
    
    if 'base_delta' in params:
        delta = params['base_delta']
    elif 'delta' in params:
        delta = params['delta']
    else:
        raise ValueError("D4 seed missing 'base_delta' or 'delta' parameter")
    
    # Generate affine then XOR
    return bytes([((s0 + i * delta) % 256) ^ xor_const for i in range(n)])


def regenerate_D5_quadratic(n: int, params: Dict[str, Any]) -> bytes:
    """
    D5 Quadratic Law: S[i] = (a*i² + b*i + c) mod 256
    
    Generative formula: Quadratic sequence with wraparound
    """
    if 'a' not in params or 'b' not in params or 'c' not in params:
        raise ValueError("D5 seed missing 'a', 'b', or 'c' parameter")
    
    a = params['a']
    b = params['b']
    c = params['c']
    
    return bytes([((a * i * i) + (b * i) + c) % 256 for i in range(n)])


def regenerate_D6_mirror(n: int, params: Dict[str, Any]) -> bytes:
    """
    D6 Mirror Law: S[i] = S[n-1-i] (palindromic symmetry)
    
    Generative formula: F(i) = B[min(i, n-1-i)]
    Stores only first half, mirrors to reconstruct full string.
    """
    # Handle multiple parameter names:
    # - 'pattern' (strict recognizer)
    # - 'half' (sampled recognizer)
    if 'pattern' in params:
        pattern = params['pattern']
    elif 'half' in params:
        pattern = params['half']
    else:
        raise ValueError("D6 seed missing 'pattern' or 'half' parameter")

    
    # For even n: result = pattern + pattern[::-1]
    # For odd n: result = pattern + pattern[-2::-1] (exclude middle)
    if n % 2 == 0:
        # Even: mirror all of first half
        return bytes(pattern + pattern[::-1])
    else:
        # Odd: mirror all but middle element
        return bytes(pattern + pattern[-2::-1])


def regenerate_D7_rotational(n: int, params: Dict[str, Any]) -> bytes:
    """
    D7 Rotational Law: S[i] = pattern[(i * stride) mod period]
    
    Generative formula: F(i; P, r, k) = P[(i·r) mod k]
    where gcd(r, k) = 1 (bijective permutation)
    """
    if 'pattern' not in params or 'stride' not in params:
        raise ValueError("D7 seed missing 'pattern' or 'stride' parameter")
    
    pattern = params['pattern']
    stride = params['stride']
    period = len(pattern)
    
    # Generate: S[i] = P[(i * stride) mod period]
    return bytes([pattern[(i * stride) % period] for i in range(n)])


def regenerate_D9_radial(n: int, params: Dict[str, Any]) -> bytes:
    """
    D9 Radial Law: S[i] = D_r(i) where r = |i - center|
    
    Causal ring-law projection: each ring has its own sub-seed.
    Generative formula: F(i; c, {r→Σ_r}) = project(Σ_r, j) where r = |i-c|
    """
    if 'center' not in params:
        raise ValueError("D9 seed missing 'center' parameter")
    
    center = params['center']

    # Parametric meta-law support (abstraction level 1)
    meta = params.get('meta') or params.get('meta_law')
    if meta is not None:
        meta_type = meta.get('type')
        if meta_type != 'D2_AFFINE_CONSTANT_DELTA':
            raise ValueError(f"Unknown D9 meta-law type: {meta_type}")

        base_s0 = int(meta['base_s0']) & 0xFF
        gradient_s0 = int(meta['gradient_s0']) & 0xFF
        delta = int(meta['delta']) & 0xFF

        result = bytearray(n)
        for i in range(n):
            r = abs(i - center)
            s0 = (base_s0 + r * gradient_s0) & 0xFF
            if i < center:
                result[i] = s0
            elif i > center:
                result[i] = (s0 + delta) & 0xFF
            else:
                result[i] = s0
        return bytes(result)
    
    # New causal format: ring_laws
    if 'ring_laws' in params:
        ring_laws = params['ring_laws']
        completion = (params.get('completion') or 'AUTO').upper()

        def _inv_mod_256(x: int) -> int | None:
            x &= 0xFF
            if x % 2 == 0:
                return None
            return pow(x, -1, 256)

        def _nearest_radius(sampled: list[int], target: int) -> int:
            best_r = sampled[0]
            best_d = abs(best_r - target)
            for sr in sampled[1:]:
                d = abs(sr - target)
                if d < best_d or (d == best_d and sr < best_r):
                    best_r, best_d = sr, d
            return best_r

        result = bytearray(n)
        
        for i in range(n):
            r = abs(i - center)
            
            # Find ring seed (may be stored as int or str key)
            if r in ring_laws:
                ring_seed = ring_laws[r]
            elif str(r) in ring_laws:
                ring_seed = ring_laws[str(r)]
            else:
                sampled_radii = sorted([int(k) if isinstance(k, str) else k for k in ring_laws.keys()])
                ring_seed = None

                if completion in {'AUTO', 'AFFINE_BRACKET'}:
                    below = [sr for sr in sampled_radii if sr < r]
                    above = [sr for sr in sampled_radii if sr > r]
                    if below and above:
                        r_below = below[-1]
                        r_above = above[0]
                        seed_below = ring_laws[r_below] if r_below in ring_laws else ring_laws[str(r_below)]
                        seed_above = ring_laws[r_above] if r_above in ring_laws else ring_laws[str(r_above)]

                        if (
                            seed_below.get('family') == 'D2' and seed_above.get('family') == 'D2' and
                            seed_below['params'].get('delta') == seed_above['params'].get('delta')
                        ):
                            s0_below = int(seed_below['params']['s0']) & 0xFF
                            s0_above = int(seed_above['params']['s0']) & 0xFF
                            delta = int(seed_below['params']['delta']) & 0xFF
                            denom = (r_above - r_below) & 0xFF
                            inv = _inv_mod_256(denom)
                            if inv is not None:
                                gradient = ((s0_above - s0_below) * inv) & 0xFF
                                s0_r = (s0_below + gradient * (r - r_below)) & 0xFF
                                ring_seed = {
                                    'family': 'D2',
                                    'params': {'s0': int(s0_r), 'delta': int(delta)},
                                    'n': 2 if r > 0 else 1
                                }
                            elif completion == 'AFFINE_BRACKET':
                                raise ValueError(
                                    f"D9 completion AFFINE_BRACKET failed: non-invertible denom={r_above - r_below} (mod 256)"
                                )
                        elif completion == 'AFFINE_BRACKET':
                            raise ValueError("D9 completion AFFINE_BRACKET failed: bracketing rings not compatible")

                if ring_seed is None:
                    if completion in {'STRICT', 'AFFINE_BRACKET'}:
                        raise ValueError(f"D9 completion {completion} failed: missing ring r={r} and no valid derivation")
                    nearest_r = _nearest_radius(sampled_radii, r)
                    ring_seed = ring_laws[nearest_r] if nearest_r in ring_laws else ring_laws[str(nearest_r)]
            
            # Determine local index within ring
            if r == 0:
                j = 0
            elif i < center:
                j = 0
            else:
                j = 1 if ring_seed['n'] > 1 else 0
            
            # Recursively regenerate from ring sub-law
            ring_bytes = regenerate_from_seed(ring_seed)
            result[i] = ring_bytes[j]
        
        return bytes(result)
    
    # Alternative format: radial_pattern
    elif 'radial_pattern' in params or 'radial' in params:
        radial = params.get('radial_pattern') or params.get('radial')
        return bytes([radial[abs(i - center)] for i in range(n)])
    
    else:
        raise ValueError("D9 seed missing 'ring_laws' or 'radial_pattern' parameter")


def regenerate_D10_spiral(n: int, params: Dict[str, Any]) -> bytes:
    """
    D10 Spiral Law: S[i] = pattern[(multiplier * i) mod n]
    
    Generative formula: F(i; P, a, n) = P[(a·i) mod n]
    Bijective permutation access where gcd(a, n) = 1
    """
    if 'pattern' not in params or 'multiplier' not in params:
        raise ValueError("D10 seed missing 'pattern' or 'multiplier' parameter")
    
    pattern = params['pattern']
    a = params['multiplier']
    
    # Generate: S[i] = P[(a·i) mod n]
    return bytes([pattern[(a * i) % n] for i in range(n)])


def regenerate_D_SPLIT(n: int, params: Dict[str, Any]) -> bytes:
    """
    D_SPLIT Compositional Law: S = concat(segments)
    
    Generative formula: Recursively regenerate each segment and concatenate
    """
    if 'segments' not in params:
        raise ValueError("D_SPLIT seed missing 'segments' parameter")
    
    segments = params['segments']
    result = b''
    
    for segment_info in segments:
        # Convert segment structure to proper seed format
        if 'law_family' in segment_info:
            # D_SPLIT stores segments with law_family, not family
            segment_seed = {
                'family': segment_info['law_family'],
                'params': segment_info.get('params', {}),
                'n': segment_info.get('length', 0)
            }
        else:
            # Already proper seed format
            segment_seed = segment_info
        
        # Recursive regeneration
        segment = regenerate_from_seed(segment_seed)
        result += segment
    
    # Verify total length
    if len(result) != n:
        raise ValueError(f"D_SPLIT length mismatch: expected {n}, got {len(result)}")
    
    return result


def regenerate_D11_universal(n: int, params: Dict[str, Any]) -> bytes:
    """
    D11 Universal Law: Lookup table generator
    
    The generator function is f(i) = table[i]
    This IS a law - a piecewise constant function defined by the table.
    
    Regeneration: Apply the generator function for each position.
    """
    generator_type = params.get('type', 'lookup_table')
    
    if generator_type == 'lookup_table':
        # Generator function: f(i) = generator[i]
        generator = params.get('generator', [])
        if isinstance(generator, list):
            return bytes(generator[:n])
        return generator[:n]
    
    # Backward compatibility: old data format
    if 'data' in params:
        data = params['data']
        if isinstance(data, list):
            return bytes(data[:n])
        return data[:n]
    
    if 'data_b64' in params:
        import base64
        return base64.b64decode(params['data_b64'])[:n]
    
    raise ValueError(f"D11_UNIVERSAL: Unknown generator type '{generator_type}'")


def regenerate_Sigma0(n: int, params: Dict[str, Any]) -> bytes:
    """
    Σ₀: Vocabulary Gap - Law Not Implemented
    
    Σ₀ means: The generative law EXISTS (guaranteed by S's existence)
    but is not yet implemented in the vocabulary.
    
    This function CANNOT regenerate because the law isn't implemented.
    The structural invariants are not sufficient - need the actual generative law.
    
    Correct response: Raise error indicating vocabulary needs expansion.
    """
    raise NotImplementedError(
        "Σ₀ regeneration requires implementing the generative law. "
        "The law exists (guaranteed by string existence), "
        "but vocabulary hasn't instantiated it yet. "
        "Structural invariants alone don't determine S - need the generator function."
    )


def regenerate_D_SPLIT_deduced(n: int, params: Dict[str, Any]) -> bytes:
    """
    D_SPLIT_DEDUCED: Deduced compositional law
    
    NOTE: After reconstruction alignment, deduction returns complete D_SPLIT seeds.
    This function should rarely be called since deduction uses 'D_SPLIT' family.
    
    If this is called with old-style deduced seeds (only region count),
    it cannot regenerate.
    """
    # Check if this is a complete seed (has segments)
    if 'segments' in params:
        # This is actually a D_SPLIT seed, delegate to D_SPLIT regenerator
        return regenerate_D_SPLIT(n, params)
    
    # Old-style deduced seed (incomplete)
    raise ValueError(
        "D_SPLIT_DEDUCED with only region count cannot regenerate. "
        "Deduction should now return complete D_SPLIT seeds with segment boundaries. "
        "This indicates an old or incomplete seed."
    )


# ========================================
# RECONSTRUCTION VALIDATION
# ========================================

def assert_regeneration(S: bytes, Sigma: Dict[str, Any]) -> None:
    """
    Test that Σ can exactly regenerate S.
    
    Raises AssertionError if reconstruction fails or produces different output.
    """
    S_hat = regenerate_from_seed(Sigma)
    
    if S_hat != S:
        raise AssertionError(
            f"RECONSTRUCTION FAILED: "
            f"Original length {len(S)}, regenerated length {len(S_hat)}, "
            f"mismatch at byte {_find_first_mismatch(S, S_hat)}"
        )


def _find_first_mismatch(S1: bytes, S2: bytes) -> int:
    """Find position of first byte that differs."""
    min_len = min(len(S1), len(S2))
    for i in range(min_len):
        if S1[i] != S2[i]:
            return i
    return min_len  # Length mismatch
